<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PokemonCenter</title>
    <script src="./three.js"></script>
    <script src="./dat.gui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/lights/RectAreaLightUniformsLib.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="webgl-output"></div>
    <script type="module">

        function main() {
            
        /*--------------------------------------- camera settings ---------------------------------------*/
        // set camera as perspective camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // default view
        camera.position.set(0, 11, 11);
        //camera.lookAt(0, 8, 10);

        // Pokecenter view
        // camera.position.set(20, 10, -15);
        // camera.lookAt(20, 5, -25);

        // river view
        // camera.position.set(0, 20, 80);
        // camera.lookAt(0, 3, 0);









        
        /*--------------------------------------- camera movement ---------------------------------------*/
        // use PointerLockControls for  better movement ( 더 자유럽고 자연스러운 카메라 움직임 )
        const controls = new THREE.PointerLockControls(camera, document.body); // set controls as PointerLockControls ( 카메라 컨트롤러 활성화 )
        document.addEventListener('click', () => controls.lock());             // lock the controls on user document click ( 클릭시 컨트롤러 활성화 )

        // camera movement speed variables ( 카메라 이동속도변수 )
        const speed = 0.5;
        const verticalSpeed = 0.3;
        // movement directions - set as false so the camera doesn't move when no keys are pressed ( 키가 눌리지 않았을때 카메라가 움직이지 않도록 false로 설정 )
        const move = { forward: false, backward: false, left: false, right: false, up: false, down: false };

        // when key is pressed change setting to true ( 키가 눌렸을때 true로 설정 )
        document.addEventListener('keydown', (event) => {
            switch (event.code) {
            case 'KeyW': move.forward = true; break;
            case 'KeyS': move.backward = true; break;
            case 'KeyA': move.left = true; break;
            case 'KeyD': move.right = true; break;
            case 'Space': move.up = true; break;
            case 'ShiftLeft': move.down = true; break;
            }
        });
        // when key is released change setting to false ( 키가 떼어졌을때 false로 설정 )
        document.addEventListener('keyup', (event) => {
            switch (event.code) {
            case 'KeyW': move.forward = false; break;
            case 'KeyS': move.backward = false; break;
            case 'KeyA': move.left = false; break;
            case 'KeyD': move.right = false; break;
            case 'Space': move.up = false; break;
            case 'ShiftLeft': move.down = false; break;
            }
        });
        









        /*----------------------------------------- create scene ----------------------------------------*/

        // basic setup
        const scene = new THREE.Scene();
        const loader = new THREE.TextureLoader();

        // set skybox texture
        new THREE.TextureLoader().load('texture/sky.png', function (texture) {
            scene.background = texture;
        });

        // create plane and add texture
        {
            const planeGeometry = new THREE.PlaneGeometry(100, 80);
            const planeTexture = loader.load('texture/grass.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            const planeMaterial = new THREE.MeshPhongMaterial({ map: planeTexture, side: THREE.DoubleSide });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);
        }










        /*------------------- light setting -------------------*/

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Hemisphere light
        const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
        scene.add(hemisphereLight);

        // pointlight
        const pointLight1 = new THREE.PointLight(0xffffff, 0, 100);
        const pointLight2 = new THREE.PointLight(0xffffff, 0, 100);
        const pointLight3 = new THREE.PointLight(0xffffff, 0, 100);
        const pointLight4 = new THREE.PointLight(0xffffff, 0, 100);
        
        scene.add(pointLight1);
        scene.add(pointLight2);
        scene.add(pointLight3);
        scene.add(pointLight4);

        pointLight1.position.set(30, 19, -10);
        pointLight2.position.set(30, 19, -20);
        pointLight3.position.set(10, 19, -20);
        pointLight4.position.set(10, 19, -10);










        /*------------------- texture function -------------------*/
        
        // colors
        const wall_white = new THREE.MeshPhongMaterial({ color: '#d6d6cd', shininess: 100, reflectivity: 0.5, metalness: 0.3, roughness: 0.7, side: THREE.DoubleSide });
        const shelf_white = new THREE.MeshPhongMaterial({ color: '#d6d6cd', side: THREE.DoubleSide });

        const white_shad = new THREE.MeshPhongMaterial({ color: '#b0b0a8', shininess: 100, reflectivity: 0.5, metalness: 0.3, roughness: 0.7, side: THREE.DoubleSide });
        const wall_red = new THREE.MeshPhongMaterial({ color: '#990000', shininess: 50, reflectivity: 0.5, metalness: 0.3, roughness: 0.7, side: THREE.DoubleSide });
        const wall_brown = new THREE.MeshPhongMaterial({ color: '#3e321f' })
        const black = new THREE.MeshPhongMaterial({ color: '#000000' });
        const orange = new THREE.MeshPhongMaterial({ color: '#f5aa42' });
        const sidewalk_grey = new THREE.MeshPhongMaterial({ color: '#707070', side: THREE.DoubleSide });
        const blackMetal = new THREE.MeshPhongMaterial({ color: '#2B2D2F', shininess: 0, metalness: 0.5, roughness: 1, side: THREE.DoubleSide });
        const lightMat = new THREE.MeshBasicMaterial({ color: "#FFDF99", transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        const window_blue = new THREE.MeshPhongMaterial({ color: '#91c4c5', transparent: true, opacity: 0.5, side: THREE.DoubleSide });
        const seatBlue = new THREE.MeshBasicMaterial({ color: '#19c8d9' });
        const seatMustard = new THREE.MeshBasicMaterial({ color: '#FFCC49' });
        const healingGreen = new THREE.MeshPhongMaterial({ color: '#008000' });

        // textures
        const centerFloor = new THREE.MeshBasicMaterial({ 
            map: loader.load('texture/centerFloor.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(6, 4);
            })
        });
        const whiteTile = new THREE.MeshPhongMaterial({
            map: loader.load('texture/whiteTile.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            }),
            side: THREE.DoubleSide
        });
        const dirt = new THREE.MeshPhongMaterial({
            map: loader.load('texture/dirt.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 1);
            })
        });
        const centerLogo = new THREE.MeshPhongMaterial({
            map: loader.load('texture/centerLogo2.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            }),
            side: THREE.DoubleSide
        });
        const barkMat = new THREE.MeshPhongMaterial({
            map: loader.load('texture/bark.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            })
        });
        const leafMat = new THREE.MeshPhongMaterial({
            map: loader.load('texture/leaf2.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(3, 3);
            })
        });
        const water = new THREE.MeshPhongMaterial({
            map: loader.load('texture/water.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(5, 1);
            }),
            side: THREE.DoubleSide
        });
        const riverDirt = new THREE.MeshPhongMaterial({
            map: loader.load('texture/dirt2.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 1);
            }),
            side: THREE.DoubleSide
        });
        const bushMat2 = new THREE.MeshPhongMaterial({
            map: loader.load('texture/bush2.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            })
        });
        const stone = new THREE.MeshPhongMaterial({
            map: loader.load('texture/stone.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            }),
            side: THREE.DoubleSide
        });
        const poster = new THREE.MeshPhongMaterial({
            map: loader.load('texture/poster.png', function (texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            }),
            side: THREE.DoubleSide
        });
        const nurse = new THREE.MeshBasicMaterial({
            map: loader.load('texture/nurse.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            }),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const chansey = new THREE.MeshBasicMaterial({
            map: loader.load('texture/chansey.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            }),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const poke_screen = new THREE.MeshPhongMaterial({
            map: loader.load('texture/poke_screen.png', function (texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            }),
            side: THREE.DoubleSide
        });
        const magikarpMaterial = new THREE.MeshPhongMaterial({
            map: loader.load('texture/magikarp.png'),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const lakituMaterial = new THREE.MeshPhongMaterial({
            map: loader.load('texture/lakitu.png'),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const droneMaterial = new THREE.MeshPhongMaterial({
            map: loader.load('texture/drone.png'),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const hudMaterial = new THREE.MeshBasicMaterial({
            map: loader.load('texture/hud1.png'),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });

        // Dynamic texture repeat
        function applyTextureRepeat(material, geometry) {
            const size = new THREE.Vector3();
            geometry.computeBoundingBox();
            geometry.boundingBox.getSize(size);

            const texture = material.map;
            if (texture) {
                texture.repeat.set(size.x, size.y);
            }
        }










        /*------------------- Basic geometry functions -------------------*/

        function createBox(x, y, z, material, w, h, d, rotationX = 0, rotationY = 0, rotationZ = 0) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x, h/2+y, z);
            box.rotation.set(rotationX, rotationY, rotationZ);
            return box;
        }
        function createSphere(x, y, z, material, radius) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            return sphere;
        }
        function createHalfSphere(x, y, z, material, radius) {
            const geometry = new THREE.SphereGeometry(radius, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const halfSphere = new THREE.Mesh(geometry, material);
            halfSphere.position.set(x, y, z);
            return halfSphere;
        }
        function createCylinder(x, y, z, material, radius1 = 1, radius2 = 1, height = 1, openEnded = false, thetaLength = 2) {
            const geometry = new THREE.CylinderGeometry(radius1, radius2, height, 32, 1, openEnded, 0, thetaLength * Math.PI);
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.set(x, height/2 + y, z);
            return cylinder;
        }
        function createTube(x = 0, y = 0, z = 0, material, inner, outer, height, thetaLength = 2) {
            const tube = new THREE.Group();
            const innerCynGeo = new THREE.CylinderGeometry(inner, inner, height, 64, 1, true, 0, Math.PI * thetaLength);
            const outerCynGeo = new THREE.CylinderGeometry(outer, outer, height, 64, 1, true, 0, Math.PI * thetaLength);
            const ringGeo = new THREE.RingGeometry(inner, outer, 64, 1, 0, Math.PI * thetaLength);
            const innerCyn = new THREE.Mesh(innerCynGeo, material);
            const outerCyn = new THREE.Mesh(outerCynGeo, material);
            const ring1 = new THREE.Mesh(ringGeo, material);
            const ring2 = new THREE.Mesh(ringGeo, material);
            tube.add(innerCyn);
            innerCyn.add(outerCyn);
            tube.add(ring1);
            tube.add(ring2);
            ring1.rotation.x = Math.PI / 2;
            ring2.rotation.x = Math.PI / 2;
            ring1.position.y = height / 2;
            ring2.position.y = -height / 2;
            tube.position.set(x, height/2+y, z);
            return tube;
            }
        function createQuarterSphere(x, y, z, material, radius) {
                const geometry = new THREE.SphereGeometry(radius, 32, 32, 0, Math.PI / 2, 0, Math.PI / 2);
                const quarterSphere = new THREE.Mesh(geometry, material);
                quarterSphere.position.set(x, y, z);
                return quarterSphere;
            }
        function createTetra(x, y, z, material, radius, detail, rotation = 0) {
            const geometry = new THREE.TetrahedronGeometry(radius, detail);
            const tetra = new THREE.Mesh(geometry, material);
            tetra.position.set(x, radius/2-y, z);
            tetra.rotation.x = Math.PI * rotation;
            return tetra;
        }
        function createRing(x, y, z, material, inner, outer, thetaLength = 2) {
            const geometry = new THREE.RingGeometry(inner, outer, 64, 1, 0, Math.PI * thetaLength);
            const ring = new THREE.Mesh(geometry, material);
            ring.position.set(x, y, z);
            return ring;
        }

        function createInfiniteSign(x, z) {
            const width = 80; 
            const height = 7; 
            const twistFactor = 4; 

            // Left loop
            const leftCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(-width / 2, 0, 0),
                new THREE.Vector3(-width / 2, height, 0),
                new THREE.Vector3(0, height, 0),
                new THREE.Vector3(0, 0, twistFactor)
            );

            // Right loop
            const rightCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(0, 0, twistFactor),
                new THREE.Vector3(0, -height, 0),
                new THREE.Vector3(width / 2, -height, 0),
                new THREE.Vector3(width / 2, 0, 0)
            );

            // connection to left loop
            const connectBackCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(width / 2, 0, 0),
                new THREE.Vector3(width / 2, height, 0),
                new THREE.Vector3(0, height, 0),
                new THREE.Vector3(0, 0, -twistFactor)
            );

            // connection to close left loop
            const connectLeftCurve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(0, 0, -twistFactor),
                new THREE.Vector3(0, -height, 0),
                new THREE.Vector3(-width / 2, -height, 0),
                new THREE.Vector3(-width / 2, 0, 0)
            );

            // Combine all points
            const points = [
                ...leftCurve.getPoints(50),
                ...rightCurve.getPoints(50),
                ...connectBackCurve.getPoints(50),
                ...connectLeftCurve.getPoints(50)
            ];

            // Create geometry and material
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.1 });

            // Create line
            const line = new THREE.Line(geometry, material);
            line.position.set(x, 15, z);
            line.rotateX(Math.PI / 2); 
            return line;
        }










        /*------------------- Create functions -------------------*/

        function lamps(x, y, z, n = 1) {
            const lamp = new THREE.Group();
            lamp.scale.set(n, n, n);

            const lamp_base = new THREE.Group();
            lamp_base.add(createCylinder(0, 0, 0, blackMetal, 0.7, 0.7, 0.4))
            lamp_base.add(createCylinder(0, 0.3, 0, blackMetal, 0.6, 0.6, 0.5))
            lamp_base.add(createCylinder(0, 0.45, 0, blackMetal, 0.5, 0.5, 0.5))
            lamp_base.add(createCylinder(0, 0.7, 0, blackMetal, 0.3, 0.3, 1))
            lamp.add(lamp_base);

            const lamp_cone = new THREE.Group();
            lamp_cone.add(createCylinder(0, 2.5, 0, blackMetal, 0.3, 0.7, 3))
            lamp_cone.add(createCylinder(0, 5.5, 0, blackMetal, 0.4, 0.3, 0.1))
            lamp_cone.add(createCylinder(0, 5.6, 0, blackMetal, 0.4, 0.4, 0.1))
            lamp_cone.add(createCylinder(0, 5.7, 0, blackMetal, 0.5, 0.5, 0.1))
            lamp_cone.add(createCylinder(0, 5.8, 0, blackMetal, 0.3, 0.3, 0.1))
            lamp_cone.position.y=-1;
            lamp_base.add(lamp_cone);

            const lamp_pole = new THREE.Group();
            lamp_pole.add(createCylinder(0, 9, 0, blackMetal, 0.2, 0.2, 12))
            lamp_pole.add(createCylinder(0, 10, 0, blackMetal, 0.3, 0.3, 0.1))
            lamp_pole.add(createCylinder(0, 18, 0, blackMetal, 0.3, 0.3, 1))
            lamp_pole.add(createCylinder(0, 18.1, 0, blackMetal, 0.4, 0.4, 0.5))
            lamp_pole.position.y=-3.5;
            lamp_cone.add(lamp_pole);

            const lamp_head = new THREE.Group();
            lamp_head.add(createCylinder(0, 0, 0, blackMetal, 0.7, 0.7, 0.1))
            lamp_head.add(createSphere(0, -0.6, 0, blackMetal, 0.4))
            lamp_head.add(createCylinder(0, 0.1, 0, lightMat, 0.7, 0.5, 1.5))
            lamp_head.add(createCylinder(0, 1.6, 0, blackMetal, 0.9, 0.9, 0.15))
            lamp_head.add(createHalfSphere(0, 1.7, 0, blackMetal, 0.6))
            lamp_head.add(createCylinder(0, 2.25, 0, blackMetal, 0.05, 0.1, 0.2))
            lamp_head.add(createBox(0, 0.1, 0.65, blackMetal, 0.07, 1.6, 0.07, 0.15))
            lamp_head.add(createBox(0, 0.1, -0.65, blackMetal, 0.07, 1.6, 0.07, -0.15))
            lamp_head.add(createBox(0.65, 0.1, 0, blackMetal, 0.07, 1.6, 0.07, 0, 0, -0.15))
            lamp_head.add(createBox(-0.65, 0.1, 0, blackMetal, 0.07, 1.6, 0.07, 0, 0, 0.15))
            lamp_head.position.y = 21;
            lamp_pole.add(lamp_head);

            const lamp_light = new THREE.PointLight(0xffffbb, 4, 20); // oxffffbb: color, 1: intensity, 20: distance
            lamp_light.position.set(0, 1, 0);
            lamp_head.add(lamp_light);

            lamp.position.set(x, y, z);
            return lamp;
        }
        
        function tree(x, y, z) {
            const tree = new THREE.Group();
            tree.scale.set(0.7, 0.7, 0.7)

            tree.add(createCylinder(0, 0, 0, barkMat, 5, 5, 10))
            const leaves = new THREE.Group();
            //main
            leaves.add(createCylinder(0, 0, 0, leafMat, 0, 15, 15));
            leaves.add(createCylinder(0, 6, 0, leafMat, 0, 14, 15));
            leaves.add(createCylinder(0, 12, 0, leafMat, 0, 12, 20));

            leaves.position.y = 7;
            tree.add(leaves);
            tree.position.set(x, y, z);
            return tree;
        }
        
        function Bushline(x, y, z, rotation = 0, n) {
                const bushline = new THREE.Group();
                bushline.add(createTetra(0, 0, 0, bushMat2, 3, 10, 0.1));
                bushline.add(createTetra(6, 0, 0, bushMat2, 3, 3, 0.4));
                bushline.add(createTetra(12, 0, 0, bushMat2, 3, 3, 0.7));
                bushline.add(createTetra(18, 0, 0, bushMat2, 3, 3, 0.3));
                bushline.add(createTetra(24, 0, 0, bushMat2, 3, 3, 0.3));
                bushline.add(createTetra(30, 0, 0, bushMat2, 3, 3, 0.3));
                

                bushline.position.set(x, y, z);
                bushline.rotation.y = Math.PI * rotation;
                bushline.scale.set(n, n, n)
                return bushline;
            }

        function seat(x, y, z, color){
            const seat = new THREE.Group();
            seat.add(createBox(0, 0, 0, wall_white, 3, 1, 3));
            seat.add(createBox(0, 1, 0, color, 3.1, 0.5, 3.1));
            seat.position.set(x, y, z);
            return seat;

        }

        function table(x, y, z){
            const table = new THREE.Group();
            //main table
            table.add(createBox(0, 1, 0, wall_white, 4, 0.5, 4));
            
            //four legs
            table.add(createBox(1.75, 0, 1.75, wall_white, 0.5, 1, 0.5));
            table.add(createBox(1.75, 0, -1.75, wall_white, 0.5, 1, 0.5));
            table.add(createBox(-1.75, 0, 1.75, wall_white, 0.5, 1, 0.5));
            table.add(createBox(-1.75, 0, -1.75, wall_white, 0.5, 1, 0.5));

            table.position.set(x, y, z);
            return table;
        }

        function sofa(x, y, z){
            const sofa = new THREE.Group();
            //main sofa
            sofa.add(createBox(0, 0, 0, wall_white, 6, 1, 2));
            sofa.add(createBox(0, 1, 0, seatBlue, 6.1, 0.5, 2));
            //back
            sofa.add(createBox(0, 0, -1.25, wall_white, 6, 3.5, 0.5));

            sofa.position.set(x, y, z);
            return sofa;
        }

        function createBook(x, y, z, material){
            const book = new THREE.Group();
            
            book.add(createCylinder(0, 0.2, 0, material, 0.1, 0.1, 0.8, false, 1).rotateZ(Math.PI / 2));
            book.add(createBox(0, 0.1, 0.09, material, 0.8, 0.5, 0.02));
            book.add(createBox(0, 0.1, -0.09, material, 0.8, 0.5, 0.02));
            book.add(createBox(0, 0.12, 0, wall_white, 0.78, 0.49, 0.18));
            book.position.set(x, y, z);
            book.rotateZ(Math.PI / 2);
            return book;
        }

        function bookline(x, y, z, N=16) {
            const bookline = new THREE.Group();
            const colors = ['#ff0000', '#006400', '#0000ff', '#0000ff', '#ff0000', '#006400', '#ff0000', '#0000ff', '#ffff00', '#006400', 
                            '#0000ff', '#ff0000', '#006400', '#0000ff', '#006400', '#ff0000', '#ffff00', '#0000ff', '#ff0000', '#006400'];

            for (let i = 0; i < N; i++) {
                const color = colors[i % colors.length];
                const material = new THREE.MeshPhongMaterial({ color: color });
                bookline.add(createBook(-1, 2.5, -1.8 + i * 0.2, material));
            }
            bookline.position.set(x, y, z);
            return bookline;
        }

        function shelf(x, y, z){
            const shelf = new THREE.Group();
            // frame
            shelf.add(createBox(0, 0, 0, shelf_white, 0.4, 5, 4));
            shelf.add(createBox(-0.8, 0, 2.2, shelf_white, 2, 4, 0.4));
            shelf.add(createBox(-0.8, 0, 2.4, sidewalk_grey,  2, 4, 0.01));
            shelf.add(createBox(-0.8, 0, -2.2, shelf_white, 2, 4, 0.4));
            shelf.add(createBox(-0.8, 0, -2.4, sidewalk_grey,  2, 4, 0.01));
            shelf.add(createBox(-1, 0, 0, shelf_white, 1.5, 0.4, 4));
            shelf.add(createBox(-1, 0.4, 0, sidewalk_grey, 1.5, 0.01, 4));
            shelf.add(createBox(-1, 1.5, 0, shelf_white, 1.5, 0.4, 4));
            shelf.add(createBox(-1, 1.9, 0, sidewalk_grey, 1.5, 0.01, 4));
            shelf.add(createBox(-1, 3, 0, shelf_white, 1.5, 0.4, 4));
            shelf.add(createBox(-1, 3.4, 0, sidewalk_grey, 1.5, 0.01, 4));
            // curve
            
            //books
            shelf.add(bookline(0, 1.2, 0, 3));
            shelf.add(bookline(0, -0.2, 0.7));
            shelf.add(bookline(0, 3.3, 0, 19).rotateX(Math.PI / 1));

            shelf.position.set(x, y, z);
            return shelf;
        }

        function magikarp(x, y, z) {
            const magikarpPlane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), magikarpMaterial);
            magikarpPlane.position.set(x, y, z);
            magikarpPlane.rotation.y = Math.PI;
            return magikarpPlane;
        }

        function lakitu(x, y, z) {
            const lakituPlane = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), lakituMaterial);
            lakituPlane.position.set(x, y, z);
            lakituPlane.rotation.y = Math.PI;
            lakituPlane.userData.direction=0.35;
            return lakituPlane;
        }

        function createNurse(x, y, z) {
            const nursePlane = new THREE.Mesh(new THREE.PlaneGeometry(5, 10), nurse);
            nursePlane.position.set(x, y, z);
            return nursePlane;
        }

        function createChansey(x, y, z) {
            const chanseyPlane = new THREE.Mesh(new THREE.PlaneGeometry(5, 7.5), chansey);
            chanseyPlane.position.set(x, y, z);
            return chanseyPlane;
        }

        function createPokeball(x, y, z){
            const pokeball = new THREE.Group();
            const halfSphere1 = createHalfSphere(0, 0, 0, new THREE.MeshPhongMaterial({ color: 0xff0000 }), 1);
            const halfSphere2 = createHalfSphere(0, 0, 0, new THREE.MeshPhongMaterial({ color: 0xffffff }), 1);
            halfSphere2.rotation.x = Math.PI;
            const ring = createCylinder(0, 0, 0, new THREE.MeshPhongMaterial({ color: 0x000000 }), 1, 1, 0.1);

            const button = createCylinder(0, -0.45, 0.5, new THREE.MeshPhongMaterial({ color: 0x000000 }), 0.25, 0.25, 1);
            button.rotateX(Math.PI / 2);
            const button2 = createCylinder(0, -0.45, 0.501, new THREE.MeshPhongMaterial({ color: 0xffffff }), 0.175, 0.175, 1);
            button2.rotateX(Math.PI / 2);
            const button3 = createCylinder(0, -0.45, 0.502, new THREE.MeshPhongMaterial({ color: 0x000000 }), 0.13, 0.13, 1);
            button3.rotateX(Math.PI / 2);
            const button4 = createCylinder(0, -0.45, 0.51, new THREE.MeshPhongMaterial({ color: 0xffffff }), 0.12, 0.12, 1);
            button4.rotateX(Math.PI / 2);


            pokeball.add(halfSphere1);
            pokeball.add(halfSphere2);
            pokeball.add(ring);
            pokeball.add(button);
            pokeball.add(button2);
            pokeball.add(button3);
            pokeball.add(button4);
            pokeball.position.set(x, y, z);
            pokeball.scale.set(0.7, 0.7, 0.7)
            return pokeball;
        }

        function createDrone(x, y, z) {
            const dronePlane = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), droneMaterial);
            dronePlane.position.set(x, y, z);
            return dronePlane;
        }

        function createHud(x, y, z) {
            const hudPlane = new THREE.Mesh(new THREE.PlaneGeometry(1024, 578), hudMaterial);
            hudPlane.position.set(x, y, z);
            hudPlane.scale.set(0.003, 0.003, 0.003);
            return hudPlane;
        }










        /*------------------ building functions ------------------*/

        scene.add(createBox(30, 19, -10, whiteTile, 1, 1, 1));
        scene.add(createBox(30, 19, -20, whiteTile, 1, 1, 1));
        scene.add(createBox(10, 19, -10, whiteTile, 1, 1, 1));
        scene.add(createBox(10, 19, -20, whiteTile, 1, 1, 1));

        function PokeCenter(){
            const centerH = 13;
            const PokeCenter = new THREE.Group();
            function firstFloor(){
                const centerWalls = new THREE.Group();
                // floor
                centerWalls.add(createBox(0, 0.8, 0, centerFloor, 36, 0.1, 21));
                centerWalls.add(createBox(0, 0, 11.2, whiteTile, 35, 1.0, 2.2));
                centerWalls.add(createBox(0, 0, -11.2, whiteTile, 35, 1.0, 2.2));
                centerWalls.add(createBox(19, 0, 0, whiteTile, 2.2, 1.0, 18.5));
                centerWalls.add(createBox(-19, 0, 0, whiteTile, 2.2, 1.0, 18.5));

                // lower rim
                centerWalls.add(createBox(0, 0, 13, blackMetal, 30, 1, 0.5));
                centerWalls.add(createBox(0, 0, -13, blackMetal, 30, 1, 0.5));
                centerWalls.add(createBox(20.5, 0, 0, blackMetal, 0.5, 1, 15));
                centerWalls.add(createBox(-20.5, 0, 0, blackMetal, 0.5, 1, 15));
                
                // [[front wall]]
                function createFrontWall(n) {
                    const frontWall = new THREE.Group();
                    // lower
                    frontWall.add(createBox(10 * n, 0, 12.5, wall_white, 10, centerH - 5, 0.5));
                    // upper
                    frontWall.add(createBox(10 * n, centerH - 1, 12.5, wall_white, 10, 1, 0.5));
                    // highlights
                    frontWall.add(createBox(12 * n, 0, 12.6, white_shad, 0.1, 5, 0.5));
                    frontWall.add(createBox(10 * n, 5, 12.6, white_shad, 10, 0.1, 0.5));
                    // black pillar
                    frontWall.add(createBox(15 * n, 0, 12.76, blackMetal, 1, centerH, 1));
                    // window
                    frontWall.add(createBox(10 * n, centerH - 5, 12.5, blackMetal, 9, 1, 0.5));
                    frontWall.add(createBox(6 * n, centerH - 5, 12.5, blackMetal, 1, 4, 0.5));
                    frontWall.add(createBox(15 * n, centerH - 5, 12.5, blackMetal, 1, 4, 0.5));
                    frontWall.add(createBox(10 * n, centerH - 5, 12.5, window_blue, 9, 3, 0.1));
                    frontWall.add(createBox(10 * n, centerH - 2, 12.5, blackMetal, 9, 1, 0.5));
                    return frontWall;
                }

                centerWalls.add(createFrontWall(1));
                centerWalls.add(createFrontWall(-1));

                // [[back wall]]
                centerWalls.add(createBox(0, 0, -12.5, wall_white, 30, centerH, 0.5));
                centerWalls.add(createBox(15, 0, -12.76, blackMetal, 1, centerH, 1));
                centerWalls.add(createBox(-15, 0, -12.76, blackMetal, 1, centerH, 1));
                centerWalls.add(createBox(0, 0, -12.76, blackMetal, 1, centerH, 1));
                // highlights
                centerWalls.add(createBox(0, 7, -12.6, white_shad, 30, 0.1, 0.5));
                centerWalls.add(createBox(10, 0, -12.6, white_shad, 0.1, 7, 0.5));
                centerWalls.add(createBox(-10, 0, -12.6, white_shad, 0.1, 7, 0.5));
                
                // [[side walls]]
                function createSideWall(n){
                    const sideWall = new THREE.Group();
                    sideWall.add(createBox(20*n, 0, 0, wall_white, 0.5, centerH-7, 15));
                    sideWall.add(createBox(20*n, 6, 6.5, wall_white, 0.5, 7, 2));
                    sideWall.add(createBox(20*n, 6, -6.5, wall_white, 0.5, 7, 2));
                    // window
                    sideWall.add(createBox(20*n, 11, 0, wall_white, 0.5, 2, 11));
                    sideWall.add(createBox(20*n, 6, 0, window_blue, 0.1, 5, 11));
                    sideWall.add(createBox(20 * n, 6, 0, blackMetal, 0.5, 1, 11));
                    
                    sideWall.add(createBox(20 * n, 6, 2, blackMetal, 0.5, 5, 0.5));
                    sideWall.add(createBox(20 * n, 6, -2, blackMetal, 0.5, 5, 0.5));

                    // black pillar
                    sideWall.add(createBox(20.5 * n, 0, 8, blackMetal, 0.5, centerH, 1));
                    sideWall.add(createBox(20.5 * n, 0, -8, blackMetal, 0.5, centerH, 1));

                    // highlights
                    sideWall.add(createBox(20.1 * n, 0, 0, white_shad, 0.5, 5, 0.1));
                    sideWall.add(createBox(20.1 * n, 5, 0, white_shad, 0.5, 0.1, 15));

                    return sideWall;
                }
                centerWalls.add(createSideWall(1));
                centerWalls.add(createSideWall(-1));
                
                // corners
                function createCorner(){
                    const corners = new THREE.Group();
                    function createCornerTube(x, y, z, rotationY) {
                        const cornerTube = new THREE.Group();
                        cornerTube.add(createTube(x, y, z, wall_white, 4.75, 5.25, centerH, 0.5).rotateY(rotationY));
                        cornerTube.add(createTube(x, y, z, wall_white, 4.75, 5.4, 2, 0.5).rotateY(rotationY));
                        cornerTube.add(createTube(x, y, z, blackMetal, 5, 5.75, 1, 0.5).rotateY(rotationY));
                        return cornerTube;
                    }

                    corners.add(createCornerTube(15, 0, 7.5, 0));
                    corners.add(createTube(19.75, 0, 12.25, white_shad, 3, 3.5, centerH, 0.5).rotateY(Math.PI));

                    corners.add(createCornerTube(15, 0, -7.5, Math.PI / 2));
                    corners.add(createTube(19.75, 0, -12.25, white_shad, 3, 3.5, centerH, 0.5).rotateY(-Math.PI / 2));

                    corners.add(createCornerTube(-15, 0, -7.5, Math.PI));
                    corners.add(createTube(-19.75, 0, -12.25, white_shad, 3, 3.5, centerH, 0.5));

                    corners.add(createCornerTube(-15, 0, 7.5, -Math.PI / 2));
                    corners.add(createTube(-19.75, 0, 12.25, white_shad, 3, 3.5, centerH, 0.5).rotateY(Math.PI / 2));
                    return corners;
                }
                centerWalls.add(createCorner());

                // door
                function createDoor(){
                    const door = new THREE.Group();
                    // left rim
                    door.add(createCylinder(0, 0, 12.5, wall_white, 5, 5, 14, true, 0.25).rotateY(Math.PI / -2));
                    door.add(createCylinder(0, 0, 12.5, wall_white, 5.5, 5.5, 14, true, 0.25).rotateY(Math.PI / -2));
                    door.add(createBox(-3.5, 0, 16.5, blackMetal, 0.5, 14, 1, 0, 0.8));
                    // right rim
                    door.add(createCylinder(0, 0, 12.5, wall_white, 5, 5, 14, true, 0.25).rotateY(Math.PI / 4));
                    door.add(createCylinder(0, 0, 12.5, wall_white, 5.5, 5.5, 14, true, 0.25).rotateY(Math.PI / 4));
                    door.add(createBox(3.5, 0, 16.5, blackMetal, 0.5, 14, 1, 0, -0.8));
                    // door roof
                    // door.add(createCylinder(0, 0.55, 12.5, marble, 5.5, 5.5, 0.1));
                    door.add(createCylinder(0, 0.51, 12.5, stone, 5.3, 5.3, 0.5, false, 1).rotateY(Math.PI / -2));
                    door.add(createCylinder(0, 0, 12.5, stone, 8, 8, 0.5));
                    door.add(createCylinder(0, 13, 12.5, wall_white, 6, 6, 2, false, 1).rotateY(Math.PI / -2));
                    door.add(createQuarterSphere(0, 14, 12.5, wall_red, 5.8).rotateY(Math.PI / 2));
                    door.add(createQuarterSphere(0, 14, 12.5, wall_red, 5.8));
                    door.add(createCylinder(0, 14, 12, blackMetal, 5.7, 5.7, 1, false, 1).rotateY(Math.PI / -2).rotateZ(Math.PI / 2));
                    

                    

                    return door;
                }
                centerWalls.add(createDoor());
                
                return centerWalls
            }
            function centerRoof(){
                const centerRoof = new THREE.Group();
                //ledge-front
                centerRoof.add(createCylinder(0, -18.5, 12, wall_red, 1.9, 1.9, 40, 0).rotateZ(Math.PI / 2));
                centerRoof.add(createCylinder(0, -18.5, -12, wall_red, 1.9, 1.9, 40, 0).rotateZ(Math.PI / 2));
                centerRoof.add(createCylinder(20, -10.5, 0, wall_red, 1.9, 1.9, 24, 0).rotateX(Math.PI / 2));
                centerRoof.add(createCylinder(-20, -10.5, 0, wall_red, 1.9, 1.9, 24, 0).rotateX(Math.PI / 2));
                centerRoof.add(createBox(0, 1, 12, wall_white, 40, 1, 3.8));
                centerRoof.add(createBox(0, 1, -12, wall_white, 40, 1, 3.8));
                centerRoof.add(createBox(20, 1, 0, wall_white, 3.8, 1, 24));
                centerRoof.add(createBox(-20, 1, 0, wall_white, 3.8, 1, 24));
                
                //ledge corners
                centerRoof.add(createSphere(19.9, 1.5, 11.9, wall_red, 1.95));
                centerRoof.add(createSphere(19.9, 1.5, -11.9, wall_red, 1.95));
                centerRoof.add(createSphere(-19.9, 1.5, -11.9, wall_red, 1.95));
                centerRoof.add(createSphere(-19.9, 1.5, 11.9, wall_red, 1.95));

                centerRoof.add(createCylinder(19.9, 1, 11.9, wall_white, 2, 2, 1));
                centerRoof.add(createCylinder(19.9, 1, -11.9, wall_white, 2, 2, 1));
                centerRoof.add(createCylinder(-19.9, 1, -11.9, wall_white, 2, 2, 1));
                centerRoof.add(createCylinder(-19.9, 1, 11.9, wall_white, 2, 2, 1));
                
                //second floor               
                function createSecondFloor(){
                    const secondFloor = new THREE.Group();
                    
                    function long_window(n){
                        secondFloor.add(createBox(0, 2.75, 12*n, blackMetal, 38, 1, 0.5));
                        secondFloor.add(createBox(0, 6.5, 12*n, blackMetal, 38, 0.5, 0.5));
                        secondFloor.add(createBox(0, 3.5, 12*n, window_blue, 38, 3, 0.1));
                        secondFloor.add(createBox(3, 3.5, 12*n, blackMetal, 0.5, 3, 0.5));
                        secondFloor.add(createBox(7, 3.5, 12*n, blackMetal, 0.5, 3, 0.5));
                        secondFloor.add(createBox(15, 3.5, 12*n, blackMetal, 1, 3, 0.5));
                        secondFloor.add(createBox(-3, 3.5, 12*n, blackMetal, 0.5, 3, 0.5));
                        secondFloor.add(createBox(-7, 3.5, 12*n, blackMetal, 0.5, 3, 0.5));
                        secondFloor.add(createBox(-15, 3.5, 12*n, blackMetal, 1, 3, 0.5));
                    }
                    // front window
                    secondFloor.add(long_window(1));
                    // back window
                    secondFloor.add(long_window(-1));

                    // corners
                    function createCornerWindow(x, y, z, rotationY) {
                        const cornerWindow = new THREE.Group();
                        cornerWindow.add(createCylinder(x, y, z, window_blue, 1.05, 1.05, 3, true, 0.5).rotateY(rotationY));
                        cornerWindow.add(createTube(x, y - 0.25, z, blackMetal, 0.75, 1.25, 0.5, 0.5).rotateY(rotationY));
                        cornerWindow.add(createTube(x, y + 3, z, blackMetal, 0.75, 1.25, 0.5, 0.5).rotateY(rotationY));
                        return cornerWindow;
                    }

                    secondFloor.add(createCornerWindow(19, 3.5, 11, 0));
                    secondFloor.add(createCornerWindow(-19, 3.5, 11, -Math.PI / 2));
                    secondFloor.add(createCornerWindow(19, 3.5, -11, Math.PI / 2));
                    secondFloor.add(createCornerWindow(-19, 3.5, -11, Math.PI));
                    
                    function short_windows(n){
                        secondFloor.add(createBox(20*n, 2.75, 0, blackMetal, 0.5, 1, 22.5));
                        secondFloor.add(createBox(20*n, 6.5, 0, blackMetal, 0.5, 0.5, 22.5));
                        secondFloor.add(createBox(20*n, 3.5, 0, window_blue, 0.1, 3, 22.5));
                        secondFloor.add(createBox(20*n, 3.5, 0, blackMetal, 0.5, 3, 0.5));
                        secondFloor.add(createBox(20*n, 3.5, 7.25, blackMetal, 0.5, 3, 0.5));
                        secondFloor.add(createBox(20*n, 3.5, -7.25, blackMetal, 0.5, 3, 0.5));
                    }
                    // right window
                    secondFloor.add(short_windows(1));
                    // left window
                    secondFloor.add(short_windows(-1));
                    // box
                    secondFloor.add(createBox(0, 7, 0, wall_red, 34, 0.1, 26));
                    
                    secondFloor.add(createBox(0, 7, 0, wall_red, 42, 0.1, 19));


                    secondFloor.add(createCylinder(0, -10.25, 9, wall_red, 4, 4, 34.5, true, 0.5).rotateZ(Math.PI / 2));
                    secondFloor.add(createCylinder(0, -10.25, -9, wall_red, 4, 4, 34.5, true, 0.5).rotateZ(Math.PI / 2).rotateY(Math.PI / 2));

                    secondFloor.add(createCylinder(17, -2.25, 0, wall_red, 4, 4, 18.5, true, 0.5).rotateX(-Math.PI / 2));
                    secondFloor.add(createCylinder(-17, -2.25, 0, wall_red, 4, 4, 18.5, true, 0.5).rotateX(-Math.PI / 2).rotateY(-Math.PI / 2));
                    secondFloor.add(createBox(0, 10.9, 0, wall_red, 34, 0.1, 18));

                    function createQuarterSphere(x, y, z, material, radius) {
                        const geometry = new THREE.SphereGeometry(radius, 32, 32, 0, Math.PI / 2, 0, Math.PI / 2);
                        const quarterSphere = new THREE.Mesh(geometry, material);
                        quarterSphere.position.set(x, y, z);
                        return quarterSphere;
                    }
                    
                    secondFloor.add(createQuarterSphere(17, 7, 9, wall_red, 4).rotateY(Math.PI / 2));
                    secondFloor.add(createCylinder(17, 7, 9, wall_red, 4, 4, 0.1));

                    secondFloor.add(createQuarterSphere(17, 7, -9, wall_red, 4).rotateY(-Math.PI / 1));
                    secondFloor.add(createCylinder(17, 7, -9, wall_red, 4, 4, 0.1));

                    secondFloor.add(createQuarterSphere(-17, 7, -9, wall_red, 4).rotateY(-Math.PI / 2));
                    secondFloor.add(createCylinder(-17, 7, -9, wall_red, 4, 4, 0.1));

                    secondFloor.add(createQuarterSphere(-17, 7, 9, wall_red, 4));
                    secondFloor.add(createCylinder(-17, 7, 9, wall_red, 4, 4, 0.1));
                    
                    secondFloor.add(createCylinder(0, 2.5, 0, wall_red, 5.8, 5.8, 17, false, 1).rotateX(Math.PI / 2).rotateY(Math.PI / 2));
                    
                    const logoGeometry = new THREE.PlaneGeometry(5, 5);
                    const logoPlane = new THREE.Mesh(logoGeometry, centerLogo);
                    logoPlane.position.set(0, 13.5, 8.55);
                    logoPlane.rotation.y = Math.PI;
                    secondFloor.add(logoPlane);
                    
                    return secondFloor
                }


                //roof
                centerRoof.add(createSecondFloor());
                centerRoof.position.y = centerH;
                return centerRoof
            }
            function interior(){
                const interior = new THREE.Group();
                
                // walls
                interior.add(createBox(0, 0, -12, orange, 35, 5, 0.1));
                interior.add(createBox(19.6, 0, 0, orange, 0.1, 5, 18));
                interior.add(createBox(-19.6, 0, 0, orange, 0.1, 5, 18));

                // table
                interior.add(createBox(-10, 0, -9.5, whiteTile, 1, 4, 5));
                interior.add(createBox(-10, 4, -9.5, wall_red, 2, 1, 5));
                interior.add(createBox(10, 0, -9.5, whiteTile, 1, 4, 5));
                interior.add(createBox(10, 4, -9.5, wall_red, 2, 1, 5));
                // table top
                interior.add(createCylinder(0, 0, -7, whiteTile, 10.5, 10.5, 4, true, 1).rotateY(Math.PI / -2));
                interior.add(createCylinder(0, 0, -7, whiteTile, 9.5, 9.5, 4, true, 1).rotateY(Math.PI / -2));
                interior.add(createCylinder(0, 4, -7, wall_red, 9, 9, 1, true, 1).rotateY(Math.PI / -2));
                interior.add(createCylinder(0, 4, -7, wall_red, 11, 11, 1, true, 1).rotateY(Math.PI / -2));
                interior.add(createRing(0, 4, -7, wall_red, 9, 11, 1).rotateX(Math.PI / 2));
                interior.add(createRing(0, 5, -7, wall_red, 9, 11, 1).rotateX(Math.PI / 2));
                // poster
                const posterPlane = new THREE.Mesh(new THREE.PlaneGeometry(3, 4), poster);
                posterPlane.position.set(14, 8, -12.2);
                posterPlane.rotation.y = 0;
                interior.add(posterPlane);
                // TV
                interior.add(createBox(0, 8, -10, white_shad, 15.5, 7.5, 0.5));
                interior.add(createBox(0, 8, -9.84, blackMetal, 15, 7, 0.2));
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(13, 6), poke_screen);
                screen.position.set(0, 11.5, -9.73);
                screen.rotation.y = 0;
                interior.add(screen);
                // seat
                interior.add(seat(14, 1, 8, seatBlue));
                interior.add(seat(-14, 1, 8, seatBlue));
                interior.add(seat(-10, 1, 3, seatMustard));
                interior.add(seat(10, 1, 3, seatMustard));
                interior.add(table(14, 1, 4));
                interior.add(table(-14, 1, 4));
                interior.add(sofa(-18, 1, 4).rotateY(Math.PI / 2));
                interior.add(sofa(18, 1, 4).rotateY(Math.PI / -2));
                // shelf
                interior.add(shelf(19, 1, -2));
                // healing pod
                const healingPod = new THREE.Group();
                healingPod.add(createCylinder(0, 4, -11.5, sidewalk_grey, 3.5, 3.5, 0.5, false, 1).rotateZ(Math.PI / 2).rotateX(Math.PI / 2));
                healingPod.add(createCylinder(0, 4, -11.49, wall_white, 3.4, 3.4, 0.5, false, 1).rotateZ(Math.PI / 2).rotateX(Math.PI / 2));

                healingPod.add(createBox(0, 0, -9.5, white_shad, 7, 4, 4));
                healingPod.add(createBox(3.5, 0, -9.5, wall_white, 0.5, 5, 4.5));
                healingPod.add(createBox(3.5, 5, -9.5, sidewalk_grey, 0.5, 0.1, 4.5));
                healingPod.add(createBox(-3.5, 0, -9.5, wall_white, 0.5, 5, 4.5));
                healingPod.add(createBox(-3.5, 5, -9.5, sidewalk_grey, 0.5, 0.1, 4.5));
                healingPod.add(createBox(0, 0, -7.5, wall_white, 6.5, 4.5, 0.5));

                healingPod.add(createBox(0, 3.3, -8.5, healingGreen, 1, 1, 1));
                healingPod.add(createBox(2, 3.3, -8.5, healingGreen, 1, 1, 1));
                healingPod.add(createBox(-2, 3.3, -8.5, healingGreen, 1, 1, 1));
                healingPod.add(createBox(0, 3.3, -10.5, healingGreen, 1, 1, 1));
                healingPod.add(createBox(2, 3.3, -10.5, healingGreen, 1, 1, 1));
                healingPod.add(createBox(-2, 3.3, -10.5, healingGreen, 1, 1, 1));

                healingPod.add(createBox(0, 2.5, -7.7, wall_red, 2, 0.5, 1));
                healingPod.add(createBox(0, 1.75, -7.7, wall_red, 0.5, 2, 1));

                healingPod.position.set(0, 0, 0.5);
                interior.add(healingPod);
                

                return interior
            }

            PokeCenter.add(firstFloor());
            PokeCenter.add(centerRoof());
            PokeCenter.add(interior());
            return PokeCenter
        }

        function road(){
            const road = new THREE.Group();
            road.add(createBox(0, 0, 0, dirt, 100, 0.1, 15));
            road.add(createBox(0, 0, 7.5, sidewalk_grey, 100, 1, 1));
            road.add(createBox(-20, 0, -7.5, sidewalk_grey, 60, 1, 1));
            road.add(createBox(40, 0, -7.5, sidewalk_grey, 20, 1, 1));
            road.add(lamps(-40, 0, -10, 1));
            road.add(lamps(0, 0, -10, 1));
            road.add(lamps(40, 0, -10, 1));
            road.add(lamps(-40, 0, 10, 1));
            road.add(lamps(0, 0, 10, 1));
            road.add(lamps(40, 0, 10, 1));
            
            return road
        }

        function forest(){
            const forest = new THREE.Group();
            forest.add(tree(-35, 0, -10));
            forest.add(tree(-15, 0, -10));
            forest.add(tree(-35, 0, -30));
            forest.add(tree(-15, 0, -30));
            return forest
        }

        function river(){
            const river = new THREE.Group();
            function riverPlane(){
                const riverGeometry = new THREE.PlaneGeometry(100, 20);
                const riverMaterial = water;
                const riverPlane = new THREE.Mesh(riverGeometry, riverMaterial);
                riverPlane.rotation.x = -Math.PI / 2;
                riverPlane.position.set(0, 0.1, 0);
                return riverPlane;
            }
            function riverBank(){
                const riverBankGeometry = new THREE.PlaneGeometry(100, 4);
                const riverBankPlane = new THREE.Mesh(riverBankGeometry, riverDirt);
                riverBankPlane.rotation.x = Math.PI / -3;
                riverBankPlane.position.set(0, 1, -10.3);
                return riverBankPlane;
            }
            river.add(riverPlane());
            river.add(riverBank());
            river.position.set(0, -2, 52);
            return river
        }

        function bushes(){
            const bushline = new THREE.Group();
            bushline.add(Bushline(-35, 0, 3, 0, 1));
            bushline.add(Bushline(-35, 0, 27, 0, 1));
            bushline.add(Bushline(5, 0, 27, 0, 1));
            return bushline
        }

        function magikarpJump(x, y, z, d){
            const magikarpPivot = new THREE.Object3D();
            magikarpPivot.position.set(x, y, z);
            
            magikarpPivot.add(magikarp(0, 10, 0));
            magikarpPivot.userData.direction = d;
            return magikarpPivot;
        }










        /*-------------------- scene building --------------------*/
        // ref: https://pokegalerie.com/products/in-stock-1-20-scale-world-figure-poke-house-poke-center-nurse-joy-chansey
        PokeCenter = PokeCenter();
        PokeCenter.position.set(20, 0, -15);
        scene.add(PokeCenter);

        road = road();
        road.position.set(0, 0, 15);
        scene.add(road);

        scene.add(forest());
        scene.add(river());
        scene.add(bushes());

        const magikarp1 = magikarpJump(0, -5, 50);
        scene.add(magikarp1);

        const magikarp2 = magikarpJump(0, -11, 49, 0.4);
        scene.add(magikarp2);
        const magikarp3 = magikarpJump(-5, -11, 45, 0.5);
        scene.add(magikarp3);
        const magikarp4 = magikarpJump(-10, -11, 55, 0.3);
        scene.add(magikarp4);
        

        const Lakitu = lakitu(0, 17, 50);        
        scene.add(Lakitu);

        const nursePlane = createNurse(17, 5, -15);
        scene.add(nursePlane);

        const chanseyPlane = createChansey(23, 5, -15);
        scene.add(chanseyPlane);

        const pokeball1 = createPokeball(20, 5, -25);
        const pokeball2 = createPokeball(22, 5, -25);
        const pokeball3 = createPokeball(18, 5, -25);
        const pokeball4 = createPokeball(20, 5, -23);
        const pokeball5 = createPokeball(22, 5, -23);
        const pokeball6 = createPokeball(18, 5, -23);
        scene.add(pokeball1);
        scene.add(pokeball2);
        scene.add(pokeball3);
        scene.add(pokeball4);
        scene.add(pokeball5);
        scene.add(pokeball6);










        /*-------------------- animation setup --------------------*/
        // path for Lakitu
        const path = createInfiniteSign(0, 50);
        scene.add(path);
        
        const LakituSpeed = 0.1;
        const pathPoints = path.geometry.attributes.position.array;
        const pathLength = pathPoints.length / 3;
        let pathIndex = 0;

        let pathProgress = 0;

        // add automatic doors
        const hud = createHud(0, 0, -2);
        hud.position.set(0, -0.6, -2); 
        hud.renderOrder = 999; 
        hud.material.depthTest = false;

        camera.add(hud);
        scene.add(camera);

        // automatic doors
        // 5.25, 5.25, 14, 
        // 20, 0, -15
        // 25.25, 5.25, -1
        //scene.add(createBox(20, 5.25, -1, wall_white, 5, 5, 5));
        const leftdoor = createCylinder(20, 0, -2.5, window_blue, 5.25, 5.25, 14, true, 0.25).rotateY(Math.PI / -4);
        scene.add(leftdoor);
        const rightdoor = createCylinder(20, 0, -2.5, window_blue, 5.25, 5.25, 14, true, 0.25).rotateY(0);
        scene.add(rightdoor);

        const doorPosition = new THREE.Vector3(20, 5.25, -1);
        const doorTrigger = 10;

        let doorOpened = false;

        function openDoors() {
            if (!doorOpened) {
                doorOpened = true;
                gsap.to(leftdoor.rotation, { y: Math.PI / -2, duration: 1 });
                gsap.to(rightdoor.rotation, { y: -Math.PI / -4, duration: 1 });
            }
        }

        function closeDoors() {
            if (doorOpened) {
                doorOpened = false;
                gsap.to(leftdoor.rotation, { y: Math.PI / -4, duration: 1 }); // Reset left door rotation
                gsap.to(rightdoor.rotation, { y: 0, duration: 1 }); // Reset right door rotation
            }
        }

        // door hitbox
        // const debugSphere = new THREE.Mesh(
        //     new THREE.SphereGeometry(10, 16, 16),
        //     new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
        // );
        // debugSphere.position.copy(doorPosition);
        // scene.add(debugSphere);

        








        /*------------------- object collision -------------------*/
        // Array to store manually defined collidable objects
        const collidableObjects = [];

        // Function to add an object to the collision system
        function addCollidableObject(object) {
            object.geometry.computeBoundingBox(); // Ensure bounding box is computed
            object.boundingBox = new THREE.Box3().setFromObject(object); // Create bounding box
            collidableObjects.push(object); // Add to the collidable objects array
        }

        function createWireframeBox(x, y, z, width, height, depth, color = 0xff0000) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            //const material = new THREE.MeshBasicMaterial({ color: color, wireframe: true, visible: false });
            const material = new THREE.MeshBasicMaterial({ color: color, visible: false });
            const wireframeBox = new THREE.Mesh(geometry, material);
            wireframeBox.position.set(x, y, z);
            return wireframeBox;
        }
        
        // ground & trees hitbox
        addCollidableObject(createWireframeBox(0, 0, 0, 100, 0.1, 80));
        addCollidableObject(createWireframeBox(0, -2, 50, 100, 0.1, 22));
        addCollidableObject(createWireframeBox(-25, 10, -20, 30, 30, 30));
        // lamp hitbox
        addCollidableObject(createWireframeBox(-40, 9, 5, 1, 18, 1));
        addCollidableObject(createWireframeBox(0, 9, 5, 1, 18, 1));
        addCollidableObject(createWireframeBox(+40, 9, 5, 1, 18, 1));
        addCollidableObject(createWireframeBox(-40, 9, 25, 1, 18, 1));
        addCollidableObject(createWireframeBox(0, 9, 25, 1, 18, 1));
        addCollidableObject(createWireframeBox(+40, 9, 25, 1, 18, 1));
        //pokecenter hitbox
        addCollidableObject(createWireframeBox(20, 11, -27.5, 37, 22, 1));

        addCollidableObject(createWireframeBox(40, 11, -15, 1, 22, 24));
        addCollidableObject(createWireframeBox(0, 11, -15, 1, 22, 24));
        addCollidableObject(createWireframeBox(32, 11, -2.5, 15, 22, 1));
        addCollidableObject(createWireframeBox(8, 11, -2.5, 15, 22, 1));
        addCollidableObject(createWireframeBox(20, 17.5, 0, 10, 8, 5));

        addCollidableObject(createWireframeBox(20, 23, -15, 36+5, 1, 21+5));
        addCollidableObject(createWireframeBox(20, 27, -15, 10, 5, 15));

        // Create a bounding box for the camera
        const cameraBox = new THREE.Box3(new THREE.Vector3(), new THREE.Vector3());

        // Function to check for collisions
        function checkBoundingBoxCollision() {
            // Update camera bounding box
            const boxSize = 1;
            cameraBox.setFromCenterAndSize(new THREE.Vector3(camera.position.x, camera.position.y - 4, camera.position.z), new THREE.Vector3(boxSize, 8, boxSize));

            // Check for intersections with manually added collidable objects
            for (const obj of collidableObjects) {
                obj.boundingBox.setFromObject(obj); // Update bounding box
                if (cameraBox.intersectsBox(obj.boundingBox)) {
                    return true; // Collision detected
                }
            }
            return false; // No collision
        }









        
        /*--------------------- GUI Setup ---------------------*/
        // GUI setup
        const gui = new dat.GUI();
        const lightFolder = gui.addFolder('Light Settings');
        const lightParams = {
            isDay: true
        };

        // Function to gradually change light intensity
        function gradualChangeLightIntensity(light, targetIntensity) {
            const step = 0.02; // Step for intensity change
            const interval = 20; // Milliseconds between steps
            const currentIntensity = light.intensity;

            const change = targetIntensity > currentIntensity ? step : -step;

            const intervalId = setInterval(() => {
                light.intensity += change;

                // Stop the interval when the target is reached
                if ((change > 0 && light.intensity >= targetIntensity) ||
                    (change < 0 && light.intensity <= targetIntensity)) {
                    light.intensity = targetIntensity; // Ensure exact value
                    clearInterval(intervalId);
                }
            }, interval);
        }

        // GUI toggle for day/night
        lightFolder.add(lightParams, 'isDay').name('Toggle Day/Night').onChange(() => {
            // Adjust hemisphereLight intensity
            const hemisphereTarget = lightParams.isDay ? 1 : 0.1;
            gradualChangeLightIntensity(hemisphereLight, hemisphereTarget);

            // Adjust pointLight1, 2, 3, 4 intensity
            const pointLightTarget = lightParams.isDay ? 0 : 0.2;
            gradualChangeLightIntensity(pointLight1, pointLightTarget);
            gradualChangeLightIntensity(pointLight2, pointLightTarget);
            gradualChangeLightIntensity(pointLight3, pointLightTarget);
            gradualChangeLightIntensity(pointLight4, pointLightTarget);
        });

        lightFolder.open();

        // camera movement
        const cameraFolder = gui.addFolder('Camera');
        const cameraParams = {
            animate: false
        };

        cameraFolder.add(cameraParams, 'animate').name('Toggle Camera Animation').onChange(() => {
            if (cameraParams.animate) {
            startCameraAnimation();
            } else {
            stopCameraAnimation();
            }
        });

        cameraFolder.open();

        let cameraAnimationId;
        function startCameraAnimation() {
            const radius = 80;
            const speed = 0.005;
            let angle = 0;

            function animateCamera() {
            angle += speed;
            camera.position.x = radius * Math.cos(angle);
            camera.position.z = radius * Math.sin(angle);
            camera.position.y = 20;
            camera.lookAt(0, 0, 0);
            cameraAnimationId = requestAnimationFrame(animateCamera);
            }

            animateCamera();
        }

        function stopCameraAnimation() {
            cancelAnimationFrame(cameraAnimationId);
        }

        // Movement GUI
        const movementParams = {
            flying: true, // Default to flying movement
            jumpVelocity: 0,
            onGround: true
        };

        cameraFolder.add(movementParams, 'flying').name('Flying Mode').onChange((value) => {
            if (value) movementParams.jumpVelocity = 0; // Reset jump velocity
        });

        // Constants for movement and physics
        // Constants for movement and physics
        const GRAVITY = -0.02; // Gravity constant
        const JUMP_STRENGTH = 0.5;
        const HOVER_HEIGHT = 1.0; // Hover height above ground

        function handleMovement() {
            const initialPosition = camera.position.clone(); // Save the current position

            if (movementParams.flying) {
                // Flying movement
                if (move.forward) controls.moveForward(speed);
                if (move.backward) controls.moveForward(-speed);
                if (move.left) controls.moveRight(-speed);
                if (move.right) controls.moveRight(speed);
                if (move.up) camera.position.y += verticalSpeed;
                if (move.down) camera.position.y -= verticalSpeed;
            } else {
                // Gravity-based movement
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0; // Ignore vertical component
                direction.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(direction, camera.up).normalize();

                // Horizontal movement
                if (move.forward) camera.position.addScaledVector(direction, speed);
                if (move.backward) camera.position.addScaledVector(direction, -speed);
                if (move.left) camera.position.addScaledVector(right, -speed);
                if (move.right) camera.position.addScaledVector(right, speed);

                // Jumping logic
                if (movementParams.onGround && move.up) {
                    movementParams.jumpVelocity = JUMP_STRENGTH; // Initiate jump
                    movementParams.onGround = false; // Airborne
                }

                // Apply gravity
                camera.position.y += movementParams.jumpVelocity;
                movementParams.jumpVelocity += GRAVITY;

                // Simulate ground collision using bounding boxes
                const cameraBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(camera.position.x, camera.position.y - 4, camera.position.z),
                    new THREE.Vector3(1, 8, 1) // Adjust dimensions as needed
                );

                let isOnGround = false;

                for (const obj of collidableObjects) {
                    obj.boundingBox.setFromObject(obj); // Update bounding box for transformations
                    if (cameraBox.intersectsBox(obj.boundingBox)) {
                        const objBottomY = obj.boundingBox.max.y; // Top of the ground object
                        const cameraBottomY = cameraBox.min.y; // Bottom of the camera box

                        if (cameraBottomY <= objBottomY + HOVER_HEIGHT) {
                            // Snap the camera to hover above the ground object
                            camera.position.y = objBottomY + HOVER_HEIGHT;
                            movementParams.jumpVelocity = 0; // Stop falling
                            isOnGround = true;
                        }
                    }
                }

                movementParams.onGround = isOnGround;

                if (!isOnGround) {
                    movementParams.onGround = false; // Airborne
                }
            }

            // Collision detection
            if (checkBoundingBoxCollision()) {
                camera.position.copy(initialPosition); // Revert to previous position
                movementParams.jumpVelocity = 0; // Stop vertical movement on collision
            }
        }

        // Collision detection function remains the same
        function checkBoundingBoxCollision() {
            const cameraBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(camera.position.x, camera.position.y - 4, camera.position.z),
                new THREE.Vector3(1, 8, 1) // Adjust dimensions as needed
            );

            for (const obj of collidableObjects) {
                obj.boundingBox.setFromObject(obj); // Update bounding box for transformations
                if (cameraBox.intersectsBox(obj.boundingBox)) {
                    return true; // Collision detected
                }
            }
            return false; // No collision
        }

        // Collision detection GUI
        function createBoundingBoxHelper(object) {
            const box = new THREE.BoxHelper(object, 0xff0000); // Red for debugging
            scene.add(box);
            return box;
        }
        const debugFolder = gui.addFolder('Collision');
        const debugParams = {
            showBoundingBoxes: false
        };


        // door hitbox
        const debugSphere = new THREE.Mesh(
            new THREE.SphereGeometry(10, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
        );
        debugSphere.position.copy(doorPosition);
        
        debugFolder.add(debugParams, 'showBoundingBoxes').name('Show Hitboxes').onChange(() => {
            collidableObjects.forEach((obj) => {
            if (debugParams.showBoundingBoxes) {
                obj.helper = createBoundingBoxHelper(obj);
                scene.add(debugSphere);
            } else {
                scene.remove(obj.helper);
                scene.remove(debugSphere);
            }
            });
        });

        debugFolder.open();










        /*--------------------- render setup ---------------------*/
        // Renderer setup
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        document.getElementById("webgl-output").appendChild(renderer.domElement);
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // jumping magikarp
            magikarp1.rotation.z -= 0.01;
            
            // Move magikarp4 back and forth
            magikarp2.position.x += 0.1 * magikarp2.userData.direction;
            if (magikarp2.position.x >= 40 || magikarp2.position.x <= -40) {
                magikarp2.userData.direction *= -1;
                magikarp2.rotation.y += Math.PI; // Flip the image
            }
            
            // Move magikarp3 back and forth
            magikarp3.position.x += 0.1 * magikarp3.userData.direction;
            if (magikarp3.position.x >= 40 || magikarp3.position.x <= -40) {
                magikarp3.userData.direction *= -1;
                magikarp3.rotation.y += Math.PI; // Flip the image
            }

            // Move magikarp4 back and forth
            magikarp4.position.x += 0.1 * magikarp4.userData.direction;
            if (magikarp4.position.x >= 40 || magikarp4.position.x <= -40) {
                magikarp4.userData.direction *= -1;
                magikarp4.rotation.y += Math.PI; // Flip the image
            }
            
            
            // Move Lakitu along the path
            pathProgress = (pathProgress + LakituSpeed) % pathLength;
            const currentIndex = Math.floor(pathProgress);
            const nextIndex = (currentIndex + 1) % pathLength;

            // Interpolate between current and next position
            const alpha = pathProgress - currentIndex;
            const currentX = pathPoints[currentIndex * 3];
            const currentZ = pathPoints[currentIndex * 3 + 1];
            const nextX = pathPoints[nextIndex * 3];
            const nextZ = pathPoints[nextIndex * 3 + 1];

            // Lerp between positions for smooth movement
            Lakitu.position.x = currentX * (1 - alpha) + nextX * alpha;
            Lakitu.position.z = 50 + currentZ * (1 - alpha) + nextZ * alpha;
            Lakitu.position.y = 15 + Math.sin(Date.now() * 0.001) * 0.5;

            // Smooth rotation to face camera
            const targetRotation = Math.atan2(
                camera.position.x - Lakitu.position.x,
                camera.position.z - Lakitu.position.z
            );
            Lakitu.rotation.y = targetRotation;

            // Make nursePlane always face the camera
            nursePlane.lookAt(new THREE.Vector3(camera.position.x, nursePlane.position.y, camera.position.z));
            chanseyPlane.lookAt(new THREE.Vector3(camera.position.x, chanseyPlane.position.y, camera.position.z));
            
            // spin the pokeballs
            pokeball1.rotation.y += 0.02;
            pokeball2.rotation.y += 0.02;
            pokeball3.rotation.y += 0.02;
            pokeball4.rotation.y += 0.02;
            pokeball5.rotation.y += 0.02;
            pokeball6.rotation.y += 0.02;

            // Trigger open/close animations based on proximity
            const distance = camera.position.distanceTo(doorPosition);
            
            if (distance < doorTrigger) {
                openDoors();
            } else {
                closeDoors();
            }

            // Handle movement and check collisions
            handleMovement();

            renderer.render(scene, camera);
        }

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
        }

        main();
    </script>
</body>

</html>